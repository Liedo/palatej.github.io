<h3 id="ordinary-smoother-univariate">Ordinary smoother (univariate)</h3>
<h4 id="notations">Notations</h4>
<p><br /><span class="math display"><em>a</em><sub><em>t</em></sub>, <em>P</em><sub><em>t</em></sub>, <em>C</em><sub><em>t</em></sub>(=<em>P</em><sub><em>t</em></sub><em>Z</em><sub><em>t</em></sub>′), <em>f</em><sub><em>t</em></sub>, <em>e</em><sub><em>t</em></sub></span><br /> are quantities obtained in the <a href="./ordinaryfilter.md">filtering process</a>. <br /><span class="math display"><em>r</em><sub><em>t</em></sub>, <em>r</em><sub>0<em>t</em></sub>, <em>r</em><sub>1<em>t</em></sub></span><br /> are auxiliary row-matrices, while <br /><span class="math display"><em>N</em><sub><em>t</em></sub>, <em>N</em><sub>0<em>t</em></sub>, <em>N</em><sub>1<em>t</em></sub>, <em>N</em><sub>2<em>t</em></sub></span><br /> are auxiliary square matrices. Except <br /><span class="math display"><em>r</em><sub>0<em>t</em></sub>, <em>N</em><sub>0<em>t</em></sub></span><br /> which are initialised with the last values of <br /><span class="math display"><em>r</em><sub><em>t</em></sub>, <em>N</em><sub><em>t</em></sub></span><br /> , those objects are set to 0 at the beginning of the process.</p>
<p>The following notations are used:</p>
<p><br /><span class="math display">$$ \tilde a_t=E\left(\alpha_{t} | y_0 \cdots y_{n}\right)$$</span><br /></p>
<p><br /><span class="math display">$$ \tilde P_t=var\left(\alpha_{t} | y_0 \cdots y_{n}\right)$$</span><br /></p>
<p><br /><span class="math display">$$ \tilde e_t=E\left(\epsilon_{t} | y_0 \cdots y_{n}\right)$$</span><br /></p>
<h4 id="normal-recursions">Normal recursions</h4>
<h5 id="observed-t">Observed t</h5>
<p><br /><span class="math display"><em>K</em><sub><em>t</em></sub> = <em>T</em><sub><em>t</em></sub><em>C</em><sub><em>t</em></sub>/<em>f</em><sub><em>t</em></sub></span><br /><br />
<br /><span class="math display">$$ \tilde e_t = v_t / f_t - r_t K_t  $$</span><br /><br />
<br /><span class="math display">$$ \left[var \tilde e_t = 1/f_t + K_t' N_t K_t \right]$$</span><br /><br />
<br /><span class="math display">$$ r_{t-1} = \tilde e_t Z_t + r_t T_t $$</span><br /><br />
<br /><span class="math display">[<em>L</em><sub><em>t</em></sub>=<em>T</em><sub><em>t</em></sub>−<em>K</em><sub><em>t</em></sub><em>Z</em><sub><em>t</em></sub>]</span><br /><br />
<br /><span class="math display">[<em>N</em><sub><em>t</em> − 1</sub>=<em>Z</em><sub><em>t</em></sub>′<em>Z</em><sub><em>t</em></sub>/<em>f</em><sub><em>t</em></sub>+<em>L</em><sub><em>t</em></sub>′<em>N</em><sub><em>t</em></sub><em>L</em><sub><em>t</em></sub>]</span><br /></p>
<h5 id="missing-t">Missing t</h5>
<p><br /><span class="math display"><em>r</em><sub><em>t</em> − 1</sub> = <em>r</em><sub><em>t</em></sub><em>T</em><sub><em>t</em></sub></span><br /><br />
<br /><span class="math display">[<em>N</em><sub><em>t</em> − 1</sub>=<em>T</em><sub><em>t</em></sub>′<em>N</em><sub><em>t</em></sub><em>T</em><sub><em>t</em></sub>]</span><br /></p>
<h5 id="smoothed-states">Smoothed states</h5>
<p><br /><span class="math display">$$ \tilde a_t' = a_t' + r_t P_t $$</span><br /><br />
<br /><span class="math display">$$ \left[\tilde P_t = P_t + P_t N_t P_t \right] $$</span><br /></p>
<h5 id="smoothed-disturbances">Smoothed disturbances</h5>
<p><br /><span class="math display">$$ \tilde u_t = r_t S_t $$</span><br /><br />
<br /><span class="math display">$$ \left[var\left(\tilde u_t \right) = V_t-S_t' N_t S_t \right] $$</span><br /></p>
<h4 id="implementation-details">Implementation details</h4>
<p>The ordinary smoother for univariate models is implemented in the class <strong><em>demetra.ssf.univariate.OrdinarySmoother</em></strong> of the library <em>demetra-ssf</em></p>
<p>The current implementation computes successively the following quantities (observed case; operations marked with an asterisk don't imply actual matrix computations; they use functional forms):</p>
<p><br /><span class="math display"><em>x</em> = <em>r</em><sub><em>t</em></sub><em>T</em><sub><em>t</em></sub></span><br />*<br />
<br /><span class="math display">$$ \tilde e_t =\left( v_t-x C_t\right)/f_t $$</span><br /><br />
<br /><span class="math display">$$ r_{t-1} = x + \tilde e_t Z_t $$</span><br />*<br />
<br /><span class="math display"><em>A</em> = <em>x</em><em>l</em>(<em>x</em><em>l</em>(<em>N</em><sub><em>t</em></sub>)′)</span><br /><br />
<br /><span class="math display"><em>N</em><sub><em>t</em> − 1</sub> = <em>A</em> + <em>Z</em><sub><em>t</em></sub>′<em>Z</em><sub><em>t</em></sub>/<em>f</em><sub><em>t</em></sub></span><br />*</p>
<h5 id="xl-operator">xl operator</h5>
<p>The operator <br /><span class="math display"><em>x</em><em>l</em>(<em>y</em>)=<em>y</em>(<em>T</em><sub><em>t</em></sub> − <em>K</em><sub><em>t</em></sub><em>Z</em><sub><em>t</em></sub>)</span><br /></p>
<p>is computed as follows</p>
<p><br /><span class="math display"><em>q</em> = <em>y</em><em>T</em><sub><em>t</em></sub></span><br />*<br />
<br /><span class="math display"><em>w</em> = <em>q</em><em>C</em><sub><em>t</em></sub></span><br /><br />
<br /><span class="math display"><em>x</em><em>l</em>(<em>y</em>)=<em>q</em> − <em>w</em>/<em>f</em><sub><em>t</em></sub><em>Z</em><sub><em>t</em></sub></span><br />*</p>
<p>It can be applied on each row of a matrix</p>
